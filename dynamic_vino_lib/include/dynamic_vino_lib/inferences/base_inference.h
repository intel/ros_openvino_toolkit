/*
 * Copyright (c) 2018 Intel Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @brief A header file with declaration for BaseInference Class
 * @file base_inference.h
 */
#ifndef DYNAMIC_VINO_LIB_INFERENCES_BASE_INFERENCE_H
#define DYNAMIC_VINO_LIB_INFERENCES_BASE_INFERENCE_H

#include <memory>
#include <string>

#include "dynamic_vino_lib/engines/engine.h"
#include "dynamic_vino_lib/slog.h"
#include "inference_engine.hpp"
#include "opencv2/opencv.hpp"
#include "dynamic_vino_lib/models/object_detection_ssd_model.h"
#include "dynamic_vino_lib/models/object_detection_yolov2voc_model.h"


namespace Outputs
{
class BaseOutput;
}
/**
 * @brief Load a frame into the input blob(memory).
 * @param[in] orig_image frame to be put.
 * @param[in] blob Blob that points to memory.
 * @param[in] scale_factor Scale factor for loading.
 * @param[in] batch_index Indicates the batch index for the frame.
 */
template <typename T>
void matU8ToBlob(const cv::Mat& orig_image, InferenceEngine::Blob::Ptr& blob,
                 float scale_factor = 1.0, int batch_index = 0)
{
  InferenceEngine::SizeVector blob_size = blob->getTensorDesc().getDims();
  const int width = blob_size[3];
  const int height = blob_size[2];
  const int channels = blob_size[1];
  T* blob_data = blob->buffer().as<T*>();

  cv::Mat resized_image(orig_image);
  if (width != orig_image.size().width || height != orig_image.size().height)
  {
    cv::resize(orig_image, resized_image, cv::Size(width, height));
  }
  int batchOffset = batch_index * width * height * channels;

  for (int c = 0; c < channels; c++)
  {
    for (int h = 0; h < height; h++)
    {
      for (int w = 0; w < width; w++)
      {
        blob_data[batchOffset + c * width * height + h * width + w] =
            resized_image.at<cv::Vec3b>(h, w)[c] * scale_factor;
      }
    }
  }
}

namespace dynamic_vino_lib
{
/**
 * @class Result
 * @brief Base class for detection result.
 */
class Result
{
 public:
  friend class BaseInference;
  explicit Result(const cv::Rect& location);
  inline const cv::Rect getLocation() const { return location_; }

 private:
  cv::Rect location_;
};

/**
 * @class BaseInference
 * @brief Base class for network inference.
 */
class BaseInference
{
 public:
  BaseInference();
  virtual ~BaseInference();
  /**
   * @brief load the Engine instance that contains the request for
   * running netwrok on target calculation device.
   */
  void loadEngine(std::shared_ptr<Engines::Engine> engine);
  /**
   * @brief Get the loaded Engine instance.
   * @return The loaded Engine instance.
   */
  inline const std::shared_ptr<Engines::Engine> getEngine() const
  {
    return engine_;
  }
  /**
   * @brief Get the number of enqueued frames to be infered.
   * @return The number of enqueued frames to be infered.
   */
  inline const int getEnqueuedNum() const
  {
    return enqueued_frames_;
  }
  /**
   * @brief Enqueue a frame to this class.
   * The frame will be buffered but not infered yet.
   * @param[in] frame The frame to be enqueued.
   * @param[in] input_frame_loc The location of the enqueued frame with respect
   * to the frame generated by the input device.
   * @return Whether this operation is successful.
   */
  virtual bool enqueue(const cv::Mat& frame,
                       const cv::Rect& input_frame_loc) = 0;
  /**
   * @brief Start inference for all buffered frames.
   * @return Whether this operation is successful.
   */
  virtual bool submitRequest();

  virtual const void observeOutput(
      const std::shared_ptr<Outputs::BaseOutput>& output) = 0;

  /**
   * @brief This function will fetch the results of the previous inference and
   * stores the results in a result buffer array. All buffered frames will be
   * cleared.
   * @return Whether the Inference object fetches a result this time
   */
  virtual bool fetchResults();
  /**
   * @brief Get the length of the buffer result array.
   */
  virtual const int getResultsLength() const = 0;
  /**
   * @brief Get the location of result with respect
   * to the frame generated by the input device.
   * @param[in] idx The index of the result.
   */
  virtual const dynamic_vino_lib::Result* getLocationResult(int idx) const = 0;
  /**
   * @brief Get the name of the Inference instance.
   * @return The name of the Inference instance.
   */
  virtual const std::string getName() const = 0;

 protected:
  /**
    * @brief Enqueue the fram into the input blob of the target calculation
    * device. Check OpenVINO document for detailed information.
    * @return Whether this operation is successful.
    */
  template <typename T>
  bool enqueue(const cv::Mat& frame, const cv::Rect&, float scale_factor,
               int batch_index, const std::string& input_name)
  {
    if (enqueued_frames_ == max_batch_size_)
    {
      slog::warn << "Number of " << getName() << "input more than maximum("
                 << max_batch_size_ << ") processed by inference" << slog::endl;
      return false;
    }

    InferenceEngine::Blob::Ptr input_blob =
        engine_->getRequest()->GetBlob(input_name);
    matU8ToBlob<T>(frame, input_blob, scale_factor, batch_index);
    enqueued_frames_ += 1;
    return true;
  }

  /**
   * @brief Set the max batch size for one inference.
   */
  inline void setMaxBatchSize(int max_batch_size)
  {
    max_batch_size_ = max_batch_size;
  }
  std::shared_ptr<Engines::Engine> engine_;
  int enqueued_frames_ = 0;

 private:
  int max_batch_size_ = 1;
  bool results_fetched_ = false;
};

class ObjectDetectionResult : public Result {
 public:
  friend class ObjectDetection;
  explicit ObjectDetectionResult(const cv::Rect& location);
  std::string getLabel() const { return label_; }
  /**
   * @brief Get the confidence that the detected area is a face.
   * @return The confidence value. 
   */
  float getConfidence() const { return confidence_; }
  bool operator<(const ObjectDetectionResult &s2) const
  {
    return this->confidence_ > s2.confidence_;
  }

  std::string label_ = "";
  float confidence_ = -1;
};

class ObjectDetection : public BaseInference
{
 public:
  ObjectDetection() {};
  virtual void loadNetwork(std::shared_ptr<Models::ObjectDetectionModel>) = 0;
};

}  // namespace dynamic_vino_lib

#endif  // DYNAMIC_VINO_LIB_INFERENCES_BASE_INFERENCE_H
